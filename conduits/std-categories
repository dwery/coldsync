#!/usr/bin/perl
# $Id: std-categories,v 2.1 2000-11-23 03:43:45 arensb Exp $
use lib "/folks/arensb/proj/coldsync/perl/ColdSync";
use lib "/folks/arensb/proj/palm-perl";
use strict;
use ColdSync;
use ColdSync::SPC;
use Palm::StdAppInfo;

use vars qw( %Pappinfo );

use constant NumCategories => 16;

# XXX - When you delete a category on the Palm, you get a category with an
# empty name, the same ID as before, and "renamed" set to 0.
# The way to distinguish between a) a category that was deleted on the
# Palm, and b) a category that was added on the desktop is this:
#	a) "renamed" is false; ID is < 128
#	b) "renamed" is true; ID is >= 128

StartConduit("sync");
select STDERR;		# XXX - Just for debugging

my $err;
my $dbinfo;		# Information about currently-open database
my $dbh;		# Database handle

# Find out which database we're dealing with
$dbinfo = spc_get_dbinfo;
die "401 Error reading database info" if !defined($dbinfo);

# Open the database
($dbh = &dlp_OpenDB($dbinfo->{name}, 0x80))
	or die "402 Can't open database";

# Get the category list from the Palm
use vars qw( $Pappinfo_raw );	# Raw AppInfo block data
use vars qw( %Pappinfo );	# Parsed category information from AppInfo
				# block

$Pappinfo_raw = dlp_ReadAppBlock($dbh);
				# Download the AppInfo block from the Palm
&Palm::StdAppInfo::parse_StdAppInfo(\%Pappinfo, $Pappinfo_raw);
				# Parse the AppInfo block into a set of
				# categories.

print "* Palm categories:\n";
&dumphash(\%Pappinfo, "");	# XXX - Debugging
print "* Desktop categories:\n";
&dumphash($PDB->{appinfo}, "");	# XXX - Debugging

## Use the Palm's categories as a base, and insert the categories from
## the desktop.
#my $nextID = 256;		# We may need to add new categories and IDs
#				# temporarily. This gives the next category
#				# ID to be used. Category IDs are in the
#				# range 0-255, so starting at 256 ensures
#				# that there will be no conflict.
#my $i;
#
## Start by copying all of the Palm's categories to the working set.
#my $Pcats  = $Pappinfo{categories};
#my $DTcats = $PDB->{appinfo}{categories};
#
## XXX - Merge the working set with $PDB's categories
#for ($i = 0; $i < Palm::StdAppInfo::numCategories; $i++)
#{
#	# Ignore unassigned categories
#	next if !defined($Pcats->[$i]{name}) or
#		($Pcats->[$i]{name} eq "");
#
#	# Compare this Palm category to the ones on the desktop
#	# XXX - This whole comparison is currently O(n^2). It should be
#	# possible to do better.
#	# (Okay, technically, since both sets are bounded, this is O(1),
#	# but still, it'd be nice to do better.)
#	my $j;
#
#	for ($j = 0; $j < Palm::StdAppInfo::numCategories; $j++)
#	{
#		next if (!defined($DTcats->[$j]{name})) or
#			($DTcats->[$i]{name} eq "");
#		if ($Pcats->[$i]{name} eq $DTcats->[$j]{name})
#		{
#			# Found a category with the same name.
#			if ($Pcats->[$i]{id} == $DTcats->[$j]{id})
#			{
#				# Name and ID match. This is the same
#				# category.
#				# XXX - What if $i != $j ?
#			} else {
#				# Name matches, ID doesn't. Since the user
#				# most is interested in names, not IDs,
#				# this is considered to be the same
#				# category. Fix one of the IDs to match the
#				# other.
#				# XXX - What if $i != $j ?
#				$DTcats->[$j]{id} = $Pcats->[$i]{id};
#			}
#
#			# Clear the "renamed" flags in case they were set.
#			$Pcats->[$i]{renamed} = 0;
#			$DTcats->[$j]{renamed} = 0;
#		} else {
#			# The category name doesn't match. This could still
#			# be the same category, if one of the copies has
#			# the 'renamed' flag set, and they have the same ID.
#			if ($Pcats->[$i]{id} == $DTcats->[$j]{id})
#			{
#				# Different name, same ID
#				if ($Pcats->[$i]{renamed})
#				{
#					# Different name, same ID, and the
#					# Palm category was renamed. Change
#					# the name on the desktop.
#					# XXX
#				} elsif ($DTcats->[$j]{renamed})
#				{
#					# Different name, same ID, and the
#					# desktop category was renamed.
#					# Change the name on the Palm.
#					# XXX
#				} else {
#					# Different name, same ID, but
#					# neither category was renamed.
#					# Change the ID on the desktop so
#					# that it doesn't conflict.
#					# XXX
#				}
#			} else {
#				# Different name, different ID. These are
#				# different categories. Nothing to do.
#			}
#		}
#	}
#}
#
## XXX - Find new categories on the desktop
#
## Recreate the AppInfo block with category names and IDs from the working
## set.
##  @{$Pappinfo{categories}} = ();
##  @{$Pappinfo{uniqueIDs}} = ();
##  for ($i = 0; $i <= $#work; $i++)
##  {
##  	push @{$Pappinfo{uniqueIDs}}, $work[$i]->[0];
##  	push @{$Pappinfo{categories}}, $work[$i]->[1];
##  }
##  $Pappinfo{renamed} = 0;

#  print "* Renamed?\n";
#  for (@{$Pappinfo{categories}})
#  {
#  	print "$_->{name} -> $_->{renamed}\n";
#  	$_->{renamed} = undef;
#  }

# Phase 1: Underpants!

# Phase 2: Get the names and IDs in sync between the Palm and Desktop
# Phase 2.1: Look at the categories on the Palm
print STDERR "Examining Palm categories:\n";
for (my $i = 0; $i <= $#{$Pappinfo{categories}}; $i++)
{
	my $category = $Pappinfo{categories}->[$i];
	print "Category $i:\n";
	print "    Name: [$category->{name}]";
	print " ", $category->{id};
	print " RENAMED" if $category->{renamed};
	print "\n";

	my $Dcategory;		# Desktop category

	# XXX - Deal with categories deleted on the Palm: id < 128 and name
	# == ""

	if ($category->{name} eq "")
	{
		# This category doesn't exist. It may have been deleted
		$Dcategory = &find_cat_by_id($PDB->{appinfo},
					     $category->{id});
	}

	if ($category->{renamed})
	{
		# This category has been renamed. Look for a category on
		# the desktop with the same ID.

		my $Dcategory;		# Desktop category

		$Dcategory = &find_cat_by_id($PDB->{appinfo},
					     $category->{id});

		if (!defined($Dcategory))
		{
			print STDERR "\tThis category doesn't exist on the desktop.\n";
			next;
		}

		print STDERR "\tThis category exists on the desktop.\n";
		print STDERR "\tRenaming D[$Dcategory->{name}] to $category->{name}\n";
		$Dcategory->{name} = $category->{name};
		$category->{renamed} = 0;
		$Dcategory->{renamed} = 0;

		$Dcategory->{_goesto} = $i;	# Index of Palm category
	} else {
		# This category has not been renamed. Look for a category
		# on the desktop with the same name.

		my $Dcategory;		# Desktop category

		$Dcategory = &find_cat_by_name($PDB->{appinfo},
					       $category->{name});

		if (!defined($Dcategory))
		{
			print STDERR "\tThis category doesn't exist on the desktop.\n";
			next;
		}

		print STDERR "\tThis category exists on the desktop.\n";
		if ($Dcategory->{renamed})
		{
			print STDERR "\tRenaming P[$category->{name}] to $Dcategory->{name}\n";
			$category->{name} = $Dcategory->{name};
			$Dcategory->{renamed} = 0;
		}

		$Dcategory->{_goesto} = $i;	# Index of Palm category
	}
}

# Phase 2.2: Look at the categories on the desktop
print STDERR "Examining Desktop categories:\n";
for (my $i = 0; $i <= $#{$PDB->{appinfo}{categories}}; $i++)
{
	my $category = $PDB->{appinfo}{categories}->[$i];
	print "Category $i:\n";
	print "    Name: [$category->{name}]";
	print " ", $category->{id};
	print " RENAMED" if $category->{renamed};
	print "\n";

	if (defined($category->{_goesto}))
	{
		print STDERR "\tSeen it already\n";
		next;
	}

	next if $category->{name} eq "";
				# Skip undefined categories

	if ($category->{renamed})
	{
		# This category has been renamed. Look for a category on
		# the desktop with the same ID.

		my $Pcategory;		# Palm category

		$Pcategory = &find_cat_by_id(\%Pappinfo,
					     $category->{id});

		if (!defined($Pcategory))
		{
			print STDERR "\tThis category doesn't exist on the Palm.\n";
			next;
		}

		print STDERR "\tThis category exists on the Palm.\n";
		print STDERR "\tRenaming D[$Pcategory->{name}] to $category->{name}\n";
		$Pcategory->{name} = $category->{name};
		$category->{renamed} = 0;
		$Pcategory->{renamed} = 0;
	} else {
		# This category has not been renamed. Look for a category
		# on the desktop with the same name.

		my $Pcategory;		# Desktop category

		$Pcategory = &find_cat_by_name(\%Pappinfo,
					       $category->{name});

		if (!defined($Pcategory))
		{
			print STDERR "\tThis category doesn't exist on the Palm.\n";
			next;
		}

		print STDERR "\tThis category exists on the desktop.\n";
		if ($Pcategory->{renamed})
		{
			print STDERR "\tRenaming P[$category->{name}] to $Pcategory->{name}\n";
			$category->{name} = $Pcategory->{name};
			$Pcategory->{renamed} = 0;
		}
	}
}

# Phase 2.3: Move new categories to the Palm.
print STDERR "Moving new categories to the Palm:\n";
for (my $i = 0; $i <= $#{$PDB->{appinfo}{categories}}; $i++)
{
	my $category = $PDB->{appinfo}{categories}->[$i];

	next if $category->{name} eq "";

	print "Category $i:\n";
	print "    Name: [$category->{name}]";
	print " ", $category->{id};
	print " RENAMED" if $category->{renamed};
	print "\n";

	# XXX - This is the ugly part: if the category already exists on
	# the Palm, it may be at a different index, so this one needs to be
	# moved.
	# Likewise, if this is a new category, need to find an empty slot
	# for it, which also involves renumbering all records in this
	# category.

	if (!defined($category->{_goesto}))
	{
		if ($Pappinfo{categories}->[$i]{name} eq "")
		{
			print STDERR "This is a new category. It can stay at this index.\n";
		} else {
			print STDERR "This is a new category. Need to find a place for it.\n";
			my $new_index = &find_empty_cat(\%Pappinfo);

			if ($new_index < 0)
			{
				# Couldn't find a free slot. Move the records
				# in this category to Unfiled.
				# XXX
			}
		}
	} elsif ($category->{_goesto} == $i)
	{
		# This category has been dealt with, and stays put
		print STDERR "This category stays put.\n";
	} else {
		print STDERR "This category should move to $category->{_goesto}\n";
	}
}

# Phase 3: Profits!

# Upload the AppInfo block to the Palm.
# XXX - Don't do this just yet
#$Pappinfo_raw = &Palm::StdAppInfo::pack_StdAppInfo(\%Pappinfo);
#$err = &dlp_WriteAppBlock($dbh, $Pappinfo_raw);

$err = &dlp_CloseDB($dbh);

die "599 Dying for no good reason";
		# XXX - Just to avoid writing the database prematurely
EndConduit;

sub find_cat_by_name
{
	my $appinfo = shift;
	my $name = shift;

	for (@{$appinfo->{categories}})
	{
		next unless $_->{name} eq $name;
		return $_;		# Found it
	}

	return undef;			# Can't find it
}

sub find_cat_by_id
{
	my $appinfo = shift;
	my $id = shift;

	for (@{$appinfo->{categories}})
	{
		next unless $_->{id} eq $id;
		next if $_->{name} eq "";
					# Skip empty categories
		return $_;		# Found it
	}

	return undef;			# Can't find it
}

sub find_empty_cat
{
	my $appinfo = shift;
	my $i;

	for ($i = 0; $i < NumCategories; $i++)
	{
		next unless $appinfo->{categories}[$i]{name} eq "";
		return $i;
	}

	return -1;
}

# XXX - Debugging functions
sub hexdump
{
	my $prefix = shift;	# What to print in front of each line
	my $data = shift;	# The data to dump
	my $maxlines = shift;	# Max # of lines to dump
	my $offset;		# Offset of current chunk

	for ($offset = 0; $offset < length($data); $offset += 16)
	{
		my $hex;		# Hex values of the data
		my $ascii;		# ASCII values of the data
		my $chunk;		# Current chunk of data

		last if defined($maxlines) && ($offset >= ($maxlines * 16));

		$chunk = substr($data, $offset, 16);

		($hex = $chunk) =~ s/./sprintf "%02x ", ord($&)/ges;

		($ascii = $chunk) =~ y/\040-\176/./c;

		printf "%s %-48s|%-16s|\n", $prefix, $hex, $ascii;
	}
}

sub dumphash
{
	my $hash = shift;
	my $indent = shift;
	my $key;
	my $value;

	while (($key, $value) = each %{$hash})
	{
		if (ref($value) eq "HASH")
		{
			print $indent, $key, ":\n";
			&dumphash($value, $indent . "\t");
		} elsif (ref($value) eq "ARRAY")
		{
#  			my $i;

#  			print $indent, $key, ":\n";
#  			for ($i = 0; $i <= $#{$value}; $i++)
#  			{
#  				print $indent, "\t$i: [$value->[$i]]\n";
#  			}
			print $indent, $key, ":\n";
			&dumparray($value, $indent . "\t");
		} else {
			print $indent, $key, " -> [", $value, "]\n";
		}
	}
}

sub dumparray
{
	my $array = shift;
	my $indent = shift;
	my $i;

	for ($i = 0; $i <= $#{$array}; $i++)
	{
		if (ref($array->[$i]) eq "HASH")
		{
			print $indent, $i, ":\n";
			&dumphash($array->[$i], $indent . "\t");
		} elsif (ref($array->[$i]) eq "ARRAY")
		{
			print $indent, $i, ":\n";
			&dumparray($array->[$i], $indent . "\t");
		} else {
			print $indent, $i, ": ", $array->[$i], "\n";
		}
	}
}

# This is for Emacs's benefit:
# Local Variables:	***
# fill-column:	75	***
# End:			***
